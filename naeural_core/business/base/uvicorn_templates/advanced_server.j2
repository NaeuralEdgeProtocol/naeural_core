{# fastapi.j2 - ADVANCED VERSION #}
# AUTOGENERATED FILE
from fastapi import FastAPI, Request, HTTPException, Header, Depends
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from starlette.exceptions import HTTPException as StarletteHTTPException
from pathlib import Path
import re
from pydantic import BaseModel
from fastapi.middleware.cors import CORSMiddleware
from os import path as file_path

from naeural_core.utils.uvicorn_fast_api_ipc_manager import UvicornPluginComms

eng = UvicornPluginComms(port={{ manager_port }}, auth={{ manager_auth }})

app = FastAPI(
  title={{ api_title }},
  summary={{ api_summary }},
  description={{ api_description }},
  version={{ api_version }},
)

app.add_middleware(
  CORSMiddleware,
  allow_origins=["*"],
  allow_credentials=True,
  allow_methods=["*"],
  allow_headers=["*"],
)

STATIC_DIR = "{{ static_directory }}"

def get_bearer_token(authorization: str = Header(...)) -> str:
  """
  Extract Bearer token from the Authorization header (advanced version).
  
  Parameters
  ----------
  authorization : str
      The raw Authorization header. Expected format: "Bearer <token>".
  
  Returns
  -------
  str
      The extracted token (NOT validated here).
  
  Raises
  ------
  HTTPException
      If the Authorization header is missing or doesn't follow the Bearer format.
  """
  scheme, _, token = authorization.partition(" ")
  if scheme.lower() != "bearer" or not token:
    raise HTTPException(
      status_code=401,
      detail="Invalid or missing Bearer token."
    )
  return token

{% for item in node_comm_params %}
{% if item['method']=='post' %}
class {{ item['name'] }}Model(BaseModel):
  {% for arg in item['args'] %}
  {{ arg }}
  {% endfor %}

@app.post("/{{ item['name'] }}")
async def {{ item['name'] }}(
  request: {{ item['name'] }}Model,
  token: str = Depends(get_bearer_token)
):
  """{{ item['endpoint_doc'] }}"""
  {% for param in item['params'] %}
  {{ param }} = request.{{ param }}
  {% endfor %}

  result = await eng.call_plugin("{{ item['name'] }}", token{% for param in item['params'] %}, {{ param }}{% endfor %})
  return result

{% else %}

{% if item['method'] is not none %}@app.{{ item['method'] }}("/{{ item['name'] }}"){% endif %}
async def {{ item['name'] }}(
  {% for arg in item['args'] %}{{ arg }}{% if not loop.last %}, {% endif %}{% endfor %},
  token: str = Depends(get_bearer_token)
):
  """{{ item['endpoint_doc'] }}"""
  result = await eng.call_plugin("{{ item['name'] }}", token{% for param in item['params'] %}, {{ param }}{% endfor %})
  return result

{% endif %}
{% endfor %}


{% for item in html_files %}
@app.{{ item['method'] }}('{{ item['route'] }}')
async def html_route{{ loop.index }}():
  return FileResponse(file_path.join(STATIC_DIR, '{{ item['name'] }}'))

{% endfor %}


@app.exception_handler(StarletteHTTPException)
async def custom_404_handler(request: Request, exc: StarletteHTTPException):
    if exc.status_code == 404:
        pattern = re.compile(r".*\.(js|png|jpg|css|jpeg|gif|svg|ico)$")
        if pattern.match(request.url.path):
            file_path = Path(STATIC_DIR) / request.url.path.strip("/")
            if file_path.exists() and file_path.is_file():
                return FileResponse(file_path)
    raise HTTPException(status_code=404, detail="Not Found")

app.mount(f"/{STATIC_DIR}", StaticFiles(directory=STATIC_DIR), name="static")
